/** ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename  : MYEEPROM.C
**     Project   : Dilute_Test
**     Processor : MC9S08DZ60MLC
**     Component : IntEEPROM
**     Version   : Component 02.190, Driver 01.06, CPU db: 3.00.019
**     Compiler  : CodeWarrior HCS08 C Compiler
**     Date/Time : 2020/6/6, 11:18
**     Abstract  :
**         This device "IntEEPROM" implements internal EEPROM
**     Settings  :
**         Initialization:
**              Wait in methods        : Enabled
**              EEPROM clock           : 182 kHz
**
**     Contents  :
**         SetByte - byte MYEEPROM_SetByte(MYEEPROM_TAddress Addr, byte Data);
**         GetByte - byte MYEEPROM_GetByte(MYEEPROM_TAddress Addr, byte *Data);
**
**     Copyright : 1997 - 2009 Freescale Semiconductor, Inc. All Rights Reserved.
**     
**     http      : www.freescale.com
**     mail      : support@freescale.com
** ###################################################################*/

/* MODULE MYEEPROM. */

#include "MYEEPROM.h"

#define FCMD_BLANK_CHECK        0x05   /* EEPROM command code */
#define FCMD_PROGRAM            0x20   /* EEPROM command code */
#define FCMD_BURST_PROGRAM      0x25   /* EEPROM command code */
#define FCMD_SECTOR_ERASE       0x40   /* EEPROM command code */
#define FCMD_MASS_ERASE         0x41   /* EEPROM command code */
#define BM_EEPROM_ERR_MASK      48     /* Bit mask to get EEPROM error bits */
#define EEPROM_SECTOR_SIZE      0x08U  /* Size of EEPROM sector */
#define BM_EEPROM_INDEX         (EEPROM_SECTOR_SIZE - 0x01) /* Value to get index part of address */
#define BM_EEPROM_SECTOR        (~(BM_EEPROM_INDEX)) /* Value to get index part of address */


static byte EEPROMSectorBuffer[EEPROM_SECTOR_SIZE]; /* Temp. buffer for flash page */

/*
** ===================================================================
**     Method      :  MYEEPROM_LaunchCmdAndTestError (component IntEEPROM)
**
**     Description :
**         This method executes specified command and tests result of the 
**         operation.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte LaunchCmdAndTestError(byte Command_, word Addr_, byte Value_);
/*
** ===================================================================
**     Method      :  MYEEPROM_NonDestructiveUnsecureWrite (component IntEEPROM)
**
**     Description :
**         This method performs Non-destructive unsecure write.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte NonDestructiveUnsecureWrite(MYEEPROM_TAddress src, MYEEPROM_TAddress dst, word size);
/*
** ===================================================================
**     Method      :  MYEEPROM_WriteBlock (component IntEEPROM)
**
**     Description :
**         The method writes block of data to a flash memory.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte WriteBlock(MYEEPROM_TAddress src, MYEEPROM_TAddress dst, word size);

/*
** ===================================================================
**     Method      :  MYEEPROM_LaunchCmdAndTestError (component IntEEPROM)
**
**     Description :
**         This method executes specified command and tests result of the 
**         operation.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte LaunchCmdAndTestError(byte Command_, word Addr_, byte Value_)
{
  if (!FSTAT_FCCF) {                   /* Is previous command completed ? */
    return ERR_BUSY;                   /* If no then error */
  }
  SaveStatusReg();                     /* Save the PS register */
  FSTAT = 0x00;                        /* Init. EEPROM engine */
  if (FSTAT & BM_EEPROM_ERR_MASK) {    /* Protection violation or access error? */
    FSTAT = BM_EEPROM_ERR_MASK;        /* Clear FPVIOL & FACERR flag */
  }
  *(volatile byte *) (Addr_) = Value_; /* Write data to the EEPROM memory */
  FCMD = Command_;                     /* Initiate command */
  FSTAT = 0x80;                        /* Launch the command */
  if (FSTAT & BM_EEPROM_ERR_MASK) {    /* Error detected? */
    RestoreStatusReg();                /* Yes, restore status information and interrupt state */
    if (FSTAT_FPVIOL) {                /* Protect violation? */
      return ERR_PROTECT;              /* Return error code ERR_PROTECT */
    } else {
      return ERR_NOTAVAIL;             /* Return error code ERR_NOTAVAIL */
    }
  }
  RestoreStatusReg();                  /* Restore the PS register */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MYEEPROM_NonDestructiveUnsecureWrite (component IntEEPROM)
**
**     Description :
**         This method performs Non-destructive unsecure write.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte NonDestructiveUnsecureWrite(MYEEPROM_TAddress src, MYEEPROM_TAddress dst, word size)
{
  byte tmp;                            /* Temporary read destination value */
  if (!FSTAT_FCCF) {                   /* Is previous command completed ? */
    return ERR_BUSY;                   /* If no then error */
  }
  SaveStatusReg();                     /* Save status information and disable interrupts(if enabled) */
  FSTAT = 0x00;                        /* Init. EEPROM engin */
  if (FSTAT & BM_EEPROM_ERR_MASK) {    /* Protection violation or access error? */
    FSTAT = BM_EEPROM_ERR_MASK;        /* Clear FPVIOL & FACERR flag */
  }
  while (size--) {                     /* For all written bytes do: */
    while (!FSTAT_FCCF) {}             /* Wait for command completion */
    tmp = *(byte *)dst;                /* Read current byte value from FLASH */
    if (*(byte *)src != tmp) {         /* Is the src. byte equal to the dest. byte? */
      *(byte *)dst = *(byte *)src | ~tmp; /* Write byte to the flash memory, do not modify zero bits */
      FCMD = FCMD_BURST_PROGRAM;       /* Initiate burst write command */
      FSTAT = 0x80;                    /* Launch the command */
      asm nop;                         /* Wait at least four bus cycles before checking FSTAT */
      asm nop;
      asm nop;
      asm nop;
      if (FSTAT & BM_EEPROM_ERR_MASK) { /* Error detected? */
        RestoreStatusReg();            /* Yes, restore status information and interrupt state */
        if (FSTAT_FPVIOL) {            /* Protect violation? */
          return ERR_PROTECT;          /* Return error code ERR_PROTECT */
        } else {
          return ERR_NOTAVAIL;         /* Return error code ERR_NOTAVAIL */
        }
      }
    }
    ++dst;
    ++src;
  }                                    /* while */
  RestoreStatusReg();                  /* Restore status information and interrupt state */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MYEEPROM_WriteBlock (component IntEEPROM)
**
**     Description :
**         The method writes block of data to a flash memory.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte WriteBlock(MYEEPROM_TAddress src, MYEEPROM_TAddress dst, word size)
{
  word x;                              /* Tmp. var. */
  byte res;                            /* Tmp. var. for function call result */
  MYEEPROM_TAddress src_tmp = src;     /* Tmp. pointer to the src. memory */
  MYEEPROM_TAddress dst_tmp;           /* Tmp. pointer to the dest. memory */
  MYEEPROM_TAddress DstEnd = dst + size; /* Address of the first byte after the end of the dest. block */
  MYEEPROM_TAddress SrcEnd = src + size; /* Address of the first byte after the end of the src. block */
  MYEEPROM_TAddress DstEndSector = DstEnd & BM_EEPROM_SECTOR; /* Sector part of "DstEnd" address */
  MYEEPROM_TAddress DstBegSector = dst & BM_EEPROM_SECTOR; /* Sector part of the destination block address */
  word SizeBeg = 0x00;                 /* Number of bytes to save from the begin of the sector to the begin of the block */
  word SizeEnd = 0x00;                 /* Number of bytes to save from the end of block to the end of sector */

  for (dst_tmp = dst; src_tmp < SrcEnd; dst_tmp++) { /* For all bytes in dest. block do: */
    if (~*(byte *)dst_tmp & *(byte *)src_tmp) { /* Test if erase is necessary */
      if ((dst_tmp & BM_EEPROM_SECTOR) == DstBegSector) { /* If first Sector of the block should be erase do: */
        SizeBeg = dst & BM_EEPROM_INDEX; /* Count the number of bytes from the begin of the sector to the begin of the block */
        if (SizeBeg != 0x00) {         /* Does the block begin on the sector boundery? */
          for (x = 0x00; x < SizeBeg; x++) {
            EEPROMSectorBuffer[x] = ((byte *)DstBegSector)[x]; /* Save bytes to the buffer */
          }
        }
      }
      if ((dst_tmp & BM_EEPROM_SECTOR) == DstEndSector) { /* If last sector of the block should be erase do: */
        SizeEnd = (~DstEnd & BM_EEPROM_INDEX) + 0x01; /* Count the number of bytes from the end of the block to the end of the sector */
        if (SizeEnd != 0x00) {         /* Does the block end on the sector boundery? */
          for (x = 0x00; x < SizeEnd; x++) {
            EEPROMSectorBuffer[x + SizeBeg] = ((byte *)DstEnd)[x];
          }
        }
      }
      res = LaunchCmdAndTestError((byte)FCMD_SECTOR_ERASE, dst_tmp, (byte)0x00); /* Erase sector */
      if (res != ERR_OK) {             /* sector erase error? */
        return res;                    /* Yes, return error code */
      }
      src_tmp += (~dst_tmp & BM_EEPROM_INDEX); /* Increase pointer to point to src. data that should be written to the next EEPROM sector */
      dst_tmp = ((dst_tmp + EEPROM_SECTOR_SIZE) & BM_EEPROM_SECTOR) - 1; /* Increase pointer to point to the next EEPROM sector */
      while (!FSTAT_FCCF) {}           /* Wait for command completion */
    }
    src_tmp++;                         /* Increment src. address */
    if (SizeBeg != 0) {                /* Restore begin of the sector? */
      res = NonDestructiveUnsecureWrite((MYEEPROM_TAddress)&EEPROMSectorBuffer, DstBegSector, SizeBeg);
      if (res != ERR_OK) {             /* Write error? */
        return res;                    /* Yes, return error code */
      }
      while (!FSTAT_FCCF) {}           /* Wait for command completion */
    }
    if (SizeEnd != 0) {                /* Restore end of the sector? */
      res = NonDestructiveUnsecureWrite((MYEEPROM_TAddress)(&EEPROMSectorBuffer[SizeBeg]), DstEnd, SizeEnd);
      if (res != ERR_OK) {             /* Write error? */
        return res;                    /* Yes, return error code */
      }
      while (!FSTAT_FCCF) {}           /* Wait for command completion */
      SizeEnd = 0;
    }
    SizeBeg = 0;                       /* Clear pointer to the buffer */
  } /* for */                          /* for */
  res = NonDestructiveUnsecureWrite(src, dst, size); /* Write data */
  if (res != ERR_OK) {                 /* Write error? */
    return res;                        /* Yes, return error code */
  }
  while (!FSTAT_FCCF) {}               /* Wait for command completion */
  for (x = 0x00; x < size; x++) {      /* Compare src. and written block */
    if (((byte*)src)[x] != ((byte*)dst)[x]) { /* Compare source byte and written byte */
      return ERR_VALUE;                /* Source value is different from dest. value, return error */
    }
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MYEEPROM_SetByte (component IntEEPROM)
**
**     Description :
**         This method writes a given byte to a specified address in
**         EEPROM. The method also sets address pointer for <SetActByte>
**         and <GetActByte> methods (applicable only if these methods
**         are enabled). The pointer is set to address passed as the
**         parameter.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Addr            - Address to EEPROM
**         Data            - Data to write
**     Returns     :
**         ---             - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_SPEED - the bean does not work in the
**                           active speed mode 
**                           - ERR_BUSY - device is busy 
**                           - ERR_VALUE - verification of written data
**                           failed (read value does not match with
**                           written value) 
**                           - ERR_NOTAVAIL - other device-specific
**                           error 
**                           - ERR_RANGE - parameter Addr is out of range
** ===================================================================
*/
byte MYEEPROM_SetByte(MYEEPROM_TAddress Addr, byte Data)
{
  if ((Addr < MYEEPROM_AREA_START) || (Addr > MYEEPROM_AREA_END)) { /* Check addres */
    return ERR_RANGE;                  /* Address is out of EEPROM memory */
  }
  return WriteBlock((MYEEPROM_TAddress)&Data, Addr, 0x01U); /* Write block to the EEPROM */
}

/*
** ===================================================================
**     Method      :  MYEEPROM_GetByte (component IntEEPROM)
**
**     Description :
**         This method reads a byte from a specified EEPROM address.
**         The method also sets address pointer for <SetActByte> and
**         <GetActByte> methods (applicable only if these methods are
**         enabled). The pointer is set to address passed as the
**         parameter.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Addr            - EEPROM Address
**       * Data            - A pointer to the returned 8-bit data
**     Returns     :
**         ---             - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_BUSY - device is busy 
**                           - ERR_RANGE - parameter Addr is out of range
** ===================================================================
*/
byte MYEEPROM_GetByte(MYEEPROM_TAddress Addr, byte *Data)
{
  if ((Addr < MYEEPROM_AREA_START) || (Addr > MYEEPROM_AREA_END)) { /* Check addres */
    return ERR_RANGE;                  /* Address is out of EEPROM memory */
  }
  *Data = *((byte *)Addr);             /* Get byte from EEPROM */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MYEEPROM_Init (component IntEEPROM)
**
**     Description :
**         Initializes the associated peripheral(s) and the bean internal 
**         variables. The method is called automatically as a part of the 
**         application initialization code.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void MYEEPROM_Init(void)
{
  /* FSTAT: FCBEF=0,FCCF=0,FPVIOL=1,FACCERR=1,??=0,FBLANK=0,??=0,??=0 */
  setReg8(FSTAT, 0x30);                /* Clear FPVIOL & FACERR flag */ 
  /* FCNFG: EPGSEL=0 */
  clrReg8Bits(FCNFG, 0x40);            /* Set EEPROM page 0 */ 
  /* FCDIV: DIVLD=0,PRDIV8=1,DIV5=0,DIV4=0,DIV3=1,DIV2=0,DIV1=1,DIV0=0 */
  setReg8(FCDIV, 0x4A);                /* Initialize FCDIV register */ 
}

/* END MYEEPROM. */

/*
** ###################################################################
**
**     This file was created by Processor Expert 3.07 [04.46]
**     for the Freescale HCS08 series of microcontrollers.
**
** ###################################################################
*/
